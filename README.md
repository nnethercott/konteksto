# Konteksto
Solving [Contexto](https://contexto.me/en/) using greedy [hill climbing](https://en.wikipedia.org/wiki/Hill_climbing) with momentum.

![](assets/cli.png)

# Running the code
You can run Konteksto in either standalone mode as a CLI or a web app.

In standalone the solver iterates automatically in real time towards a solution, while in the web app users manually drive the solver state through word submissions.

In both cases we need a running Qdrant instance to handle vector search.

## CLI
<details>
An executable to configure and run the hill climbing algorithm in real time. Under the hood we directly contact the Contexto api to validate guesses iteratively.

The easiest way to run this is by running the commands below
```
$ docker compose up -d
$ docker-compose exec konteksto ./bin/solve --max-iters 25 --max-retries 3
```

A full list of options are configurable as below:
```bash
Usage: solve [OPTIONS]

Options:
      --game-id <GAME_ID>          [default: 42]
  -l, --lang <LANG>                language to play in; available langs are: 'en', 'pt-br', and 'es' [default: en]
      --grpc-port <GRPC_PORT>      grpc port where qdrant db is running on [env: QDRANT__SERVICE__GRPC_PORT=] [default: 6334]
      --max-retries <MAX_RETRIES>  number of times to randomly initialize search algorithm [default: 1]
      --max-iters <MAX_ITERS>      max number of iterations per solution attempt [default: 100]
      --beta <BETA>                decay rate in momemntum update [default: 0.5]
      --margin <MARGIN>            value under which "free mobility" is possible [default: 200]
  -h, --help                       Print help
```

[![asciicast](https://asciinema.org/a/7YKKIisc5J5uvDfLXtkJb2n3f.svg)](https://asciinema.org/a/7YKKIisc5J5uvDfLXtkJb2n3f)
</details>

## web
<details>
A wrapper around Contexto built using axum, sqlx, maud, and htmx providing word suggestions.

To play in either "en", "pt", or "es" simply run:
```
$ GAME_LANG=en docker compose up
```
and head to `http://localhost:5049/game/123`

There you'll have access to all games from contexto for that language, and suggestions generated by `Konteksto-engine`.

![](assets/web.png)
</details>

# Elements of the solution
## Dataset creation
Inspecting contexto's page source we find the file `/static/js/gameApi.js` which lists the API endpoints for contexto;
  * a base url `https://api.contexto.me/machado`
  * endpoint for scoring guesses: `${baseUrl}/${language}/game/${gameId}/${word}`
  * endpoint listing top words per puzzle: `${baseUrl}/${language}/top/${gameId}`

A database of ~25k words is built by scraping over 500 games using the /top/${gameId} endpoint. This allows us to have a well-defined search space

Previous attempts to build a dataset using [nltk](https://www.nltk.org/howto/corpus.html) or [publicly available lists](https://github.com/dwyl/english-words) were limited due to size (O(10^5) words) and non-overlap with contexto's own internal list

## Vector search
We use [qdrant](https://github.com/qdrant/qdrant) and [fastembed](https://github.com/qdrant/fastembed) to generate and index embeddings per language. This results in a distinct Qdrant collection for English, Portuguese, and Spanish games.

To produce the embeddings [sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2](https://huggingface.co/sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2) is used to encode non-English words, while [BAAI/bge-small-en-v1.5](https://huggingface.co/BAAI/bge-small-en-v1.5) handles English words. We configure qdrant to store vectors in `float16` format  to cut down on space, resulting in a vector store of ~ 100 MB for all 3 languages.

The grpc client is further used in addition to Rust to speed up the initial indexing process, as suggested in the [this blog post](https://qdrant.tech/articles/indexing-optimization/).

## Solver
`Konteksto-engine` leverages the Rust client for qdrant and some linalg packages to implement the hill climbing algorithm.

## Greedy hill climbing
An outline of the algorithm is provided below.
![](assets/algo.png)

Heuristically the algorithm starts from an initial seed and modifies its search direction by exploring points in its neighborhood. The main difference between this algo and gradient descent is the greedy position moves; we accept only moves to words with lower scores. The contour plots for each are quite similar though;
![](assets/contour.png)
